/* automatically generated by rust-bindgen 0.60.1 */

pub const CELT_EXTRA_VERSION: &[u8; 1usize] = b"\0";
pub const CELT_MAJOR_VERSION: u32 = 0;
pub const CELT_MICRO_VERSION: u32 = 4;
pub const CELT_MINOR_VERSION: u32 = 11;
pub const CELT_VERSION: &[u8; 7usize] = b"0.11.4\0";
pub const HAVE_ALLOCA_H: u32 = 1;
pub const HAVE_DLFCN_H: u32 = 1;
pub const HAVE_GETOPT_H: u32 = 1;
pub const HAVE_GETOPT_LONG: u32 = 1;
pub const HAVE_INTTYPES_H: u32 = 1;
pub const HAVE_LIBM: u32 = 1;
pub const HAVE_LRINT: u32 = 1;
pub const HAVE_LRINTF: u32 = 1;
pub const HAVE_MEMORY_H: u32 = 1;
pub const HAVE_STDINT_H: u32 = 1;
pub const HAVE_STDLIB_H: u32 = 1;
pub const HAVE_STRINGS_H: u32 = 1;
pub const HAVE_STRING_H: u32 = 1;
pub const HAVE_SYS_STAT_H: u32 = 1;
pub const HAVE_SYS_TYPES_H: u32 = 1;
pub const HAVE_UNISTD_H: u32 = 1;
pub const LT_OBJDIR: &[u8; 7usize] = b".libs/\0";
pub const PACKAGE_BUGREPORT: &[u8; 1usize] = b"\0";
pub const PACKAGE_NAME: &[u8; 1usize] = b"\0";
pub const PACKAGE_STRING: &[u8; 1usize] = b"\0";
pub const PACKAGE_TARNAME: &[u8; 1usize] = b"\0";
pub const PACKAGE_URL: &[u8; 1usize] = b"\0";
pub const PACKAGE_VERSION: &[u8; 1usize] = b"\0";
pub const SIZEOF_INT: u32 = 4;
pub const SIZEOF_LONG: u32 = 4;
pub const SIZEOF_LONG_LONG: u32 = 8;
pub const SIZEOF_SHORT: u32 = 2;
pub const STDC_HEADERS: u32 = 1;
pub const OPUS_BUILD: u32 = 1;
pub const CUSTOM_MODES_ONLY: u32 = 1;
pub const VAR_ARRAYS: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 36;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const CELT_OK: u32 = 0;
pub const CELT_BAD_ARG: i32 = -1;
pub const CELT_BUFFER_TOO_SMALL: i32 = -2;
pub const CELT_INTERNAL_ERROR: i32 = -3;
pub const CELT_CORRUPTED_DATA: i32 = -4;
pub const CELT_UNIMPLEMENTED: i32 = -5;
pub const CELT_INVALID_STATE: i32 = -6;
pub const CELT_ALLOC_FAIL: i32 = -7;
pub const CELT_SET_COMPLEXITY_REQUEST: u32 = 2;
pub const CELT_SET_PREDICTION_REQUEST: u32 = 4;
pub const CELT_SET_BITRATE_REQUEST: u32 = 6;
pub const CELT_RESET_STATE_REQUEST: u32 = 8;
pub const CELT_RESET_STATE: u32 = 8;
pub const CELT_SET_VBR_CONSTRAINT_REQUEST: u32 = 10;
pub const CELT_SET_VBR_REQUEST: u32 = 12;
pub const CELT_SET_INPUT_CLIPPING_REQUEST: u32 = 14;
pub const CELT_GET_AND_CLEAR_ERROR_REQUEST: u32 = 15;
pub const CELT_GET_LOOKAHEAD_REQUEST: u32 = 17;
pub const CELT_SET_CHANNELS_REQUEST: u32 = 18;
pub const CELT_SET_LOSS_PERC_REQUEST: u32 = 20;
pub const CELT_SET_START_BAND_REQUEST: u32 = 10000;
pub const CELT_SET_END_BAND_REQUEST: u32 = 10001;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__fsid_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__fsid_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type celt_int16 = i16;
pub type celt_uint16 = u16;
pub type celt_int32 = i32;
pub type celt_uint32 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CELTEncoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CELTDecoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CELTMode {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Creates a new mode struct. This will be passed to an encoder or"]
    #[doc = "decoder. The mode MUST NOT BE DESTROYED until the encoders and"]
    #[doc = "decoders that use it are destroyed as well."]
    #[doc = "@param Fs Sampling rate (32000 to 96000 Hz)"]
    #[doc = "@param frame_size Number of samples (per channel) to encode in each"]
    #[doc = "packet (even values; 64 - 512)"]
    #[doc = "@param error Returned error code (if NULL, no error will be returned)"]
    #[doc = "@return A newly created mode"]
    pub fn celt_mode_create(
        Fs: celt_int32,
        frame_size: ::std::os::raw::c_int,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut CELTMode;
}
extern "C" {
    #[doc = " Destroys a mode struct. Only call this after all encoders and"]
    #[doc = "decoders using this mode are destroyed as well."]
    #[doc = "@param mode Mode to be destroyed"]
    pub fn celt_mode_destroy(mode: *mut CELTMode);
}
extern "C" {
    pub fn celt_encoder_get_size(channels: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn celt_encoder_get_size_custom(
        mode: *const CELTMode,
        channels: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a new encoder state. Each stream needs its own encoder"]
    #[doc = "state (can't be shared across simultaneous streams)."]
    #[doc = "@param channels Number of channels"]
    #[doc = "@param error Returns an error code"]
    #[doc = "@return Newly created encoder state."]
    pub fn celt_encoder_create(
        sampling_rate: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut CELTEncoder;
}
extern "C" {
    #[doc = " Creates a new encoder state. Each stream needs its own encoder"]
    #[doc = "state (can't be shared across simultaneous streams)."]
    #[doc = "@param mode Contains all the information about the characteristics of"]
    #[doc = "  the stream (must be the same characteristics as used for the"]
    #[doc = "  decoder)"]
    #[doc = "@param channels Number of channels"]
    #[doc = "@param error Returns an error code"]
    #[doc = "@return Newly created encoder state."]
    pub fn celt_encoder_create_custom(
        mode: *const CELTMode,
        channels: ::std::os::raw::c_int,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut CELTEncoder;
}
extern "C" {
    pub fn celt_encoder_init(
        st: *mut CELTEncoder,
        sampling_rate: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut CELTEncoder;
}
extern "C" {
    pub fn celt_encoder_init_custom(
        st: *mut CELTEncoder,
        mode: *const CELTMode,
        channels: ::std::os::raw::c_int,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut CELTEncoder;
}
extern "C" {
    #[doc = " Destroys a an encoder state."]
    #[doc = "@param st Encoder state to be destroyed"]
    pub fn celt_encoder_destroy(st: *mut CELTEncoder);
}
extern "C" {
    #[doc = " Encodes a frame of audio."]
    #[doc = "@param st Encoder state"]
    #[doc = "@param pcm PCM audio in float format, with a normal range of ±1.0."]
    #[doc = "          Samples with a range beyond ±1.0 are supported but will"]
    #[doc = "          be clipped by decoders using the integer API and should"]
    #[doc = "          only be used if it is known that the far end supports"]
    #[doc = "          extended dynmaic range. There must be exactly"]
    #[doc = "          frame_size samples per channel."]
    #[doc = "@param compressed The compressed data is written here. This may not alias pcm or"]
    #[doc = "                 optional_synthesis."]
    #[doc = "@param nbCompressedBytes Maximum number of bytes to use for compressing the frame"]
    #[doc = "          (can change from one frame to another)"]
    #[doc = "@return Number of bytes written to \"compressed\". Will be the same as"]
    #[doc = "       \"nbCompressedBytes\" unless the stream is VBR and will never be larger."]
    #[doc = "       If negative, an error has occurred (see error codes). It is IMPORTANT that"]
    #[doc = "       the length returned be somehow transmitted to the decoder. Otherwise, no"]
    #[doc = "       decoding is possible."]
    pub fn celt_encode_float(
        st: *mut CELTEncoder,
        pcm: *const f32,
        frame_size: ::std::os::raw::c_int,
        compressed: *mut ::std::os::raw::c_uchar,
        maxCompressedBytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encodes a frame of audio."]
    #[doc = "@param st Encoder state"]
    #[doc = "@param pcm PCM audio in signed 16-bit format (native endian). There must be"]
    #[doc = "          exactly frame_size samples per channel."]
    #[doc = "@param compressed The compressed data is written here. This may not alias pcm or"]
    #[doc = "                         optional_synthesis."]
    #[doc = "@param nbCompressedBytes Maximum number of bytes to use for compressing the frame"]
    #[doc = "                        (can change from one frame to another)"]
    #[doc = "@return Number of bytes written to \"compressed\". Will be the same as"]
    #[doc = "       \"nbCompressedBytes\" unless the stream is VBR and will never be larger."]
    #[doc = "       If negative, an error has occurred (see error codes). It is IMPORTANT that"]
    #[doc = "       the length returned be somehow transmitted to the decoder. Otherwise, no"]
    #[doc = "       decoding is possible."]
    pub fn celt_encode(
        st: *mut CELTEncoder,
        pcm: *const celt_int16,
        frame_size: ::std::os::raw::c_int,
        compressed: *mut ::std::os::raw::c_uchar,
        maxCompressedBytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Query and set encoder parameters"]
    #[doc = "@param st Encoder state"]
    #[doc = "@param request Parameter to change or query"]
    #[doc = "@param value Pointer to a 32-bit int value"]
    #[doc = "@return Error code"]
    pub fn celt_encoder_ctl(
        st: *mut CELTEncoder,
        request: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn celt_decoder_get_size(channels: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn celt_decoder_get_size_custom(
        mode: *const CELTMode,
        channels: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a new decoder state. Each stream needs its own decoder state (can't"]
    #[doc = "be shared across simultaneous streams)."]
    #[doc = "@param mode Contains all the information about the characteristics of the"]
    #[doc = "stream (must be the same characteristics as used for the encoder)"]
    #[doc = "@param channels Number of channels"]
    #[doc = "@param error Returns an error code"]
    #[doc = "@return Newly created decoder state."]
    pub fn celt_decoder_create(
        sampling_rate: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut CELTDecoder;
}
extern "C" {
    #[doc = " Creates a new decoder state. Each stream needs its own decoder state (can't"]
    #[doc = "be shared across simultaneous streams)."]
    #[doc = "@param mode Contains all the information about the characteristics of the"]
    #[doc = "stream (must be the same characteristics as used for the encoder)"]
    #[doc = "@param channels Number of channels"]
    #[doc = "@param error Returns an error code"]
    #[doc = "@return Newly created decoder state."]
    pub fn celt_decoder_create_custom(
        mode: *const CELTMode,
        channels: ::std::os::raw::c_int,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut CELTDecoder;
}
extern "C" {
    pub fn celt_decoder_init(
        st: *mut CELTDecoder,
        sampling_rate: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut CELTDecoder;
}
extern "C" {
    pub fn celt_decoder_init_custom(
        st: *mut CELTDecoder,
        mode: *const CELTMode,
        channels: ::std::os::raw::c_int,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut CELTDecoder;
}
extern "C" {
    #[doc = " Destroys a a decoder state."]
    #[doc = "@param st Decoder state to be destroyed"]
    pub fn celt_decoder_destroy(st: *mut CELTDecoder);
}
extern "C" {
    #[doc = " Decodes a frame of audio."]
    #[doc = "@param st Decoder state"]
    #[doc = "@param data Compressed data produced by an encoder"]
    #[doc = "@param len Number of bytes to read from \"data\". This MUST be exactly the number"]
    #[doc = "of bytes returned by the encoder. Using a larger value WILL NOT WORK."]
    #[doc = "@param pcm One frame (frame_size samples per channel) of decoded PCM will be"]
    #[doc = "returned here in float format."]
    #[doc = "@return Error code."]
    pub fn celt_decode_float(
        st: *mut CELTDecoder,
        data: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        pcm: *mut f32,
        frame_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decodes a frame of audio."]
    #[doc = "@param st Decoder state"]
    #[doc = "@param data Compressed data produced by an encoder"]
    #[doc = "@param len Number of bytes to read from \"data\". This MUST be exactly the number"]
    #[doc = "of bytes returned by the encoder. Using a larger value WILL NOT WORK."]
    #[doc = "@param pcm One frame (frame_size samples per channel) of decoded PCM will be"]
    #[doc = "returned here in 16-bit PCM format (native endian)."]
    #[doc = "@return Error code."]
    pub fn celt_decode(
        st: *mut CELTDecoder,
        data: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        pcm: *mut celt_int16,
        frame_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Query and set decoder parameters"]
    #[doc = "@param st Decoder state"]
    #[doc = "@param request Parameter to change or query"]
    #[doc = "@param value Pointer to a 32-bit int value"]
    #[doc = "@return Error code"]
    pub fn celt_decoder_ctl(
        st: *mut CELTDecoder,
        request: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the English string that corresponds to an error code"]
    #[doc = " @param error Error code (negative for an error, 0 for success"]
    #[doc = " @return Constant string (must NOT be freed)"]
    pub fn celt_strerror(error: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
